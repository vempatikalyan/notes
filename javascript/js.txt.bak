Variables
=========
var x; 
 
var x, y, z; 
 
Initial value is “undefined”. 
 
Assign value: x = 5; 
 
Assign while defining var x = 5, y = 10; 
 
Variable name must start with $, _ or an alphabet. 
 
Js is case sensitive. “test” and “Test” are two different variables. 
 
var, function, return, class etc... are reserved words. 
 
Data types
==========
Javascript is a weekly typed language – we can assign any type of value to any type of variable.
// no error
var message = "hello";
message = 123456;

JavaScript is dynamically typed language. Depends on context it will decide the data type.
Ex: 10 - '2' = 8

7 kinds of data types
---------------------
'number' for numbers of any kind: integer or floating-point.
'string' for strings. A string may have one or more characters, there’s no separate single-character type.
'boolean' for true/false.
'null' for unknown values – a standalone type that has a single value null. Reference of non-existing value.
'undefined' for unassigned values – a standalone type that has a single value undefined. Existing but no value.
'object' for more complex data structures. object, array, function belong to object datatype.
'symbol' for unique identifiers.

typeof
======
typeof is used to check the datatype of variable.

typeof undefined // "undefined" 

typeof 0    // "number" 
 
typeof true // "boolean" 

typeof "foo" // "string" 

typeof {} // "object" 

typeof function(){} // "function". There is no function data type. It comes under object type. But, typeof operator returns it as function for better differentiation from objects.

typeof {} // 'object'
typeof [] // 'object'
typeof new Date() // 'object'

typeof "test" // string
typeof new String("test") // object

typeof Symbol("id") // "symbol"

Numbers
=======
Numbers in javascript range from 'Infinity' to '-Infinity'.
1/0 // Infinity
-1/0 // -Infinity

NaN
0 / 0 - failed to do mathematical calculation

NaN is not equal to anything, including itself

isNaN(0/0)

parseInt('12px')

parseFloat('12.3.4')

Except +, other operators automatically parse string to numbers
10 + '2' //"102"

It's better to parse the values while doing mathematical operation.
10 - parseInt('2'); // 8

Math.floor
Rounds down

Math.ceil
Rounds up

Math.round
Rounds to nearest

Math.floor(3.1) // 3
Math.ceil(3.1)  // 4
Math.round(3.1)  // 3


var a = 12.34;
a.toFixed(1) // "12.3"

var a = 12.34
a.toFixed(5) // "12.34000"

Math.random()

Strings
=======
var text = "my value";
var anotherText = 'another string';

We can use both double quotes or single quotes to define strings.

\ - to escape special characters in the string. 

var str = " double " quote "; // Get an error

var str = " double \" quote ";

var str = "test \
test"; // Escaping new line

str.length

str.charAt(0)

str.toUpperCase()

str.toLowerCase()

indexOf(): It is used to search substring in a string. Returns index of first occurence of substring.

var str = "Widget with id Widget";
str.indexOf("Widget")  // 0
str.indexOf("id")  // 1
str.indexOf("test")  // -1 if it can't find the substring

if(str.indexOf("Widget") !== -1) { } // Compare with -1 while using indexOf in if condition

str.indexOf("id", 2) //search from index 2

str.lastIndexOf("id"); // Returns the index of last occurence 

Extracting a substring: substring, substr, slice

substring
---------
substring(start, end) - exclude the end position

var str = "stringify"
str.substring(0,1) // s

if we don't give end, it will take upto end

substr
------
substr(start [, length])
start, how many characters to extract

var str = "stringify"
str = str.substr(2,4) // ring

omitting the length will lead to end of the string

slice
-----
slice(start [, end])
same as substring. Difference is handling the negative and overflow values.

"testme".substring(-2) //testme  negative values becomes 0
"testme".slice(-4)	//stme		count from the end of the string. backward counting starts from -1. 's' at -4. So, start at 's' and take remaining all.

"testme".slice(1, -1) //estm Start at 1, end at -1 and exclude last char.
 
Operators
=========
Arithmetic: +, -, *, /, % 
 
++ / -- increment / decrement operators 
 
Suffix: a = 2; console.log(a); console.log(a++); console.log(a); 
 
Prefix: a = 2; console.log(a); console.log(++a); 
 
Logical: AND ( && ), OR ( || ), NOT ( ! )
 
Type Conversions
================
To String
---------
var test = 123;
test.toString();

var value = true;
valStr = String(value);

To Number
---------
var str = 'abc'; 
Number(str); // NaN

var str = '123';
Number(str); // 123

To Boolean
----------
Boolean(1); // true
Boolean(0); // false

Boolean("hello"); // true
Boolean(""); // false

Boolean("0"); // String "0" gives true
Boolean(" "); // spaces, also true (any non-empty string is true)

Double not(!!) – convert any data type to Boolean.
str = 'test';
!str // false
!!str // true 

JSON <=> String
---------------
var obj = JSON.parse('{"name":"John", "age":30, "city":"New York"}');

var obj = { "name":"John", "age":30, "city":"New York"};
var myJSON = JSON.stringify(obj);


Conditional Operators
=====================
IF 
--
 
if (price > 100) { 
 
} else { 
 
} 
 
Else if 
-------
 
if (userId > 1) { 
 
} else if (userId == 1) { 
 
} else if (userId == 0) { 
 
} else { 
 
} 
 
Switch
------
switch(x) { 
  case 'value1':  // if (x === 'value1') 
    ...
    break;
  case 'value2':  // if (x === 'value2') 
    ... 
    break;
  default:        // if x doesn't match with any of the values mentioned in the cases
    // default code 
} 
 
Ternary
-------
var result = condition ? value_if_true : value_if_false;
 
Loops
=====
while(i<10) { 
  // do something
  i++; 
} 
---------------------------
do { 
  // something
  i++; 
} while (i<10) 
---------------------------
for(var i=1; i<=10; i++) { 
  console.log(i); 
} 
---------------------------
var i=1; 
for( ; i<=10; i++) { 
  console.log(i); 
} 
---------------------------
for( ; ; ) { 
  console.log("test"); 
} 
 
 
Break
-----
var i=0; 
while(true) { 
  i += 1;
  console.log(i); 
  if (i>5) {
    break; 
  }
  console.log("test"); 
} 
 
Continue
--------
var i = -3; 
while(i<3) { 
  i++; 
  if (i==0) continue; // It will skip 0 iteration and go to 1
  console.log(i); 
} 
 
Functions
=========
// Named function 
function greet(name) { 
  console.log("Hi, "+name) 
} 

// Anonymous function
var greet = function(name) { 
  console.log("Hi, "+name) 
}

greet('John');

If a function don't return anything, by default "undefined" will be returned.

variables declared inside function are local to that function.
Example: examples/scoping.html

Callback function
-----------------
We can pass one function as parameter to another function, 

function goodMorning(name) { 
  console.log("Good Morning, "+name) 
}

function goodEvening(name) { 
  console.log("Good Evening, "+name) 
}

function greetUser(callback){
	callback("John");
}

greetUser(goodMorning);
greetUser(goodEvening);

Here goodMorning, goodEvening are call back functions.

Instead of passing function using it's name, we can define the function while passing it.

greetUser(function(name) { 
  console.log("Hi, "+name) 
});

Ex: ajax folder

Self calling functions / Immediately invoked functions
------------------------------------------------------
(function() {
  
	var a = 5, b=10;
  console.log(a, b);
	
})()

all the variables become local to that self calling function block only.
Example: self invoked function folder

Global variables can be accessed from anywhere in the code. 
Local variables can be accessed within the function block only.

Using Self calling functions we can stop polluting the global scope.

In our example, we defined 'performAddition' in math.js file with out effecting 'performAddition' function in app.js

Constructor function: It is used to create objects.
---------------------
function User() {
	this.name = 'john';
	this.age = 30;
}
var user = new User();

instanceof: for checking type of custom objects
----------
user instanceof User

var test = new String("abc");
test instanceof String // true

var test2 = "tst";
test2 instanceof String // false

Arrays
======
var arr = [];
new Array()
.length
.pop()
.push() 

push and pop Operates at end.

shift/unshift operates from start.
shift - Remove the first elment.
unshift - Add new element at starting.

var fruits = ["Apple", "Orange"]

var apple = fruits.shift() // now we have only ["Orange"] left

fruits.unshift("Lemon") // now got ["Lemon", "Orange"]

console.log(fruits)

join and split
--------------
var fruits = ["Lemon","Apple","Orange","Peach"];

var str = fruits.join(', ');
console.log(str);

var fruits = "Apple,Orange,Peach";

var arr = fruits.split(',');
console.log(arr);

// arr is ["Apple", "Orange", "Peach"]

length
-------
var arr = [0, 1, 2, 3];
arr.length = 2; // trims the last two elements
arr.length = 20; // insert 18 undefined 

delete
------
var arr = ["Go", "to", "home"]
delete arr[1]
// now arr = ["Go", undefined, "home"]
console.log(arr[1]) // undefined

splice
------
arr.splice(index, deleteCount, [elem1, ..., elemN])

var arr = ["Go", "to", "home"]
arr.splice(1, 1)  // remove 1 element starting at index 1
console.log(arr); // ["Go", "home"]

splice returns array of removed elements.

replace elements:
var arr = ["Go", "to", "home", "now"];
// remove first 3 elements and add two
arr.splice(0, 3, "Come", "here") 
console.log( arr ) // ["Come", "here", "now"]

insert elements, just set deleteCount to 0
var arr = ["Go", "to", "home"];
// from 2nd position 
// delete 0 
// and insert "my", "sweet"
arr.splice(2, 0, "my", "sweet") 
console.log( arr) // "Go", "to", "my", "sweet", "home"

a negative index, which counts from array end
var arr = [1, 2, 5]

// at element -1
// delete 0 elements, 
// then insert 3 and 4
arr.splice(-1, 0, 3, 4)

console.log(arr)  // 1,2,3,4,5

Array slice
-----------
var arr = ["Why", "learn", "JavaScript"];

var arr2 = arr.slice(0,2) // starting at 0 index, end at 2 index and omit last value 

console.log(arr2);
it will return the sliced elements.
 
if we miss the end index, it will take until end.

forEach()
---------
To iterate through array elements.
var arr = ["Why", "learn", "JavaScript"];

arr.forEach(function(value, index){
  console.log(value);
  console.log(index);
});

map()
-----
Take each value and manipulate and returns the new array.
var arr = [4, 9, 16, 25];

var sqrts = arr.map(function(value, index){
	return Math.sqrt(value);
}); // [2, 3, 4, 5]

filter()
--------
Returns a new array of filtered values.
var ages = [4, 9, 16, 25];

var minorAges = ages.filter(function (value, index){
  return value <= 18;
}); // [4, 9, 16]

Reverse and sort
-----------------
arr.reverse() reverse the array. 

arr.sort() sort the array as per the compare callback function.
var points = [10, 5, 15, 7, 1];
points.sort(function(a, b){return a-b});
When the sort() method compares two values, it sends the values to the compare function, and sorts the values according to the returned (negative, zero, positive) value.

Objects
=======
var user = new Object();
var user = { };
user.name = 'John'
user.age = 25;
delete user.name

We can also use [] to access properties of object.
user['name'] // John

var key = 'name';
user.key // undefined
user[key] // John

var box = {
	width: 200,
	length: 300,
	shapes: ["square","rectangle"],
	draw: function(){
	
	},
	type: {}
} 

We can place any kind of data in object.

Non-existing properties returns undefined.
box.area  // returns undefined

JSON: JavaScript Object Notation
-----

window Object
=============
window is the global object in javascript.

var a = 10;
Here 'a' will become property in window object. We can access it as 'window.a' OR just 'a'

Object.keys() & Object.values() methods
---------------------------------------
var box = {
	width: 200,
	length: 300,
	shapes: ["square","rectangle"],
	draw: function(){
	
	},
	type: {}
} 

Object.keys(box) returns an array with all keys of box object.

Object.values(box) returns an array with all values of box object.

To check an object is empty or not, check the length of Object.keys(box) array.
var user = {};
if(user) {
	console.log('not empty');
} // If can't evaluate it.

if(Object.keys(box).length) {
  // box is not an empty object
}

this
====
> In a regular function, this will become window object
function test(){
  console.log(this); // this = window object
}

> Creating custom object:
function User(name) {
  this.name = name;
 
  this.sayHi = function() {
    console.log("I am "  + this.name)
  };
}

var john = new User("John");
var peter = new User("Peter");

john.sayHi()
peter.sayHi()

The value of this is dynamic. It is determined when function is called, not when it is declared.

> In an object method, this will become current object.
Example1:
var obj = {
  name: 'John',
  printName: function(){
    console.log(this.name);
  }
};
obj.printName(); // this = obj

Example2:
var john = { 
  firstName: "John" 
}

function print() { 
  console.log(this.firstName + ": hi!")
}

john.sayHi = print;

john.sayHi()  // this = john

call, apply and bind methods
----------------------------
func.call(context, arg1, arg2, ...)  // this = context
func.apply(context, [args])

The syntax of call:
func.call(obj, arg1, arg2,...)
The first argument of call becomes this, other arguments arg1, arg2... become arguments.

var user = { 
  firstName: "John" 
}

function print() { 
  console.log( this.firstName )
}

print() // undefined 

print.call(user)  // "John"

var user = { 
  firstName: "John",
  lastName: "Smith"
}

function print(a, b) { 
  console.log( this.firstName + ' ' + this.lastName )
  return a + b;
}

print.call(user, 2, 3)  // "John Smith"

The print.apply is same as print.call, but it accepts an array of arguments instead of list.

The following two lines are same:
print.call(user, 2, 3)
 
print.apply(user, [2, 3])

Using call and apply methods we can call the function. Using bind() method we can create new function with the given context. bind() method returns the new function with supplied context.

// Not binding any context and assigning print to printName variable
var printName = print; 

// Binding user object to print function and assigning print to printName variable
var printName = print.bind(user); 
printName(2, 3); // John Smith

Also, we can pass parameters in bind method.
var printName = print.bind(user, 2, 3);
printName(); // John Smith

OOPS
====
Prototypal inheritance
----------------------
In other languages one class inherit other class. In javascript we use 'prototype' property for inheritance.

'prototype' is a property of constructor methods.

function simpleCalc(){
	this.add = function(){
	 console.log("Addition is simple"); 
	};
  
	this.subtract = function(){
		console.log("Subtraction is simple"); 
	}
}

var simpleObj = new simpleCalc();

    
function complexCalc(){
	this.multiplication=function(){
	 console.log("Multiplication is complex"); 
	};

	this.division=function(){
		console.log("Division is complex"); 
	}
}

complexCalc.prototype = simpleObj; //Inherited simpleCalc

var complexObj = new complexCalc();

Observe complexObj.__proto__ , it should contain 'add' and 'subtract' methods in it. So, on complexObj we can access add and subtract as well.

// Another kind of constructor function
function veryComplexCalc(){
  this.modulas = function(){
    console.log("Modulas is vaery complex"); 
  }
}

veryComplexCalc.prototype = complexObj; //Inherited complexObj

var veryComplexObj = new veryComplexCalc();

Observe veryComplexObj.__proto__, it should contain 'multiplication' and 'division' methods in it. So, on veryComplexCalc we can access add, subtract, multiplication and division as well.

JavaScript objects like new String(), new Array(), new Date() etc.. inherit all properties and methods from prototype.

Closure
=======
A closure is an inner function that has access to the outer function’s variables, properties and scope.

function getCounter() {
  var count = 0;
  function counter() {
    count += 1;
    console.log(count)
  }
  return counter;
}

var count = getCounter();

count();
count();
count();

Here counter() function is closure.

Problems solved by closure
--------------------------
1. If we put 'var count = 0;' in global scope, any other script may change 'count' value. For example, if your colleague define a variable with same name, then our function doesn't work properly.

var count = 0;
function counter() {
  count += 1;
  console.log(count)
}

counter();
counter();

2. If we put 'var count = 0;' in local scope, 'count' will be initiated again and again when we call count. So, counter doesn't work properly.

function counter() {
  var count = 0;
  count += 1;
  console.log(count)
}

counter();
counter();

To overcome these kind of problems we use closures.

DOM
===
Document Object Model (DOM)
allow to access contents of the page, modify elements etc
	
The DOM represents document as a tree. The tree is made up of parent-child relationships, a parent can have one or many children nodes.

window.document is the global object for DOM. We can access it as window.document OR document.

Traversing
----------
document.body
document.body.childNodes
document.body.firstChild
document.body.lastChild

dir - method
------------
dir() is a chrome console method to expand and see the list of properties available on a DOM element.

<div id="logo">div for logo</div>
var logo = document.getElementById('logo');
console.log(logo);

dir(logo);

document.getElementById
-----------------------
<div id="info">Info</div>
<script>
  var div = document.getElementById('info')
  console.log( div.innerHTML )
</script>


getElementsByTagName
--------------------
<table id="myTable">
  <tr>
    <td>Your age:</td>

    <td>
      <label>
        <input type="radio" name="age" value="young" checked/> under 18
      </label>
      <label>
        <input type="radio" name="age" value="mature"/> from 18 to 50
      </label>
      <label>
        <input type="radio" name="age" value="senior"/> older than 60
      </label>
    </td>
  </tr>
</table>

<script>
var elements = document.getElementsByTagName('input');
  console.log(elements);
  for(var i=0; i<elements.length; i++) {
    var input = elements[i]  
    console.log(input.value+': '+input.checked)
  }
</script>

document.getElementsByClassName
-------------------------------
<div class="abc def test">some text1</div>
<div class="abc">some text2</div>
<script>
console.log( document.getElementsByClassName('abc') )
</script>

getElementsByName
------------------
<table id="myTable">
  <tr>
    <td>Your age:</td>

    <td>
      <label>
        <input type="radio" name="age" value="young" checked/> under 18
      </label>
      <label>
        <input type="radio" name="age" value="mature"/> from 18 to 50
      </label>
      <label>
        <input type="radio" name="age" value="senior"/> older than 60
      </label>
    </td>
  </tr>
</table>

<script>
  var elements = document.getElementsByName('age');
  console.log(elements);
</script>

document.querySelector, querySelectorAll
----------------------------------------
The methods querySelector and querySelectorAll allow to select elements by CSS3 query.
<ul>
  <li>The</li>
  <li>Test</li>
</ul>
<ul>
  <li>Is</li>
  <li>Passed</li>
</ul>
<script>
  var elements = document.querySelectorAll('UL > LI:last-child')

  for(var i=0; i<elements.length; i++) {
    console.log(elements[i].innerHTML )
  }
</script>

// document.querySelector - returns the first matched element.
var elem = document.querySelector('ul');
console.log(elem);

Difference b/w element attribute and element property
-----------------------------------------------------
There is a difference b/w element attributes and element properties.

Generally most of the Attributes have an equivalent Property for it. Below is an example on 'input' element's 'value' attribute and 'value' property.

<input type="text" id="name" value="John" />

var inputObj = document.getElementById("name");
var valueProperty = inputObj.value;
var valueAttribute = inputObj.getAttribute("value");

If we change the value of input, value property gets changed, but not value attribute.

Some attributes don't have equivalent properties. Ex: table span attributes etc..

<table>
    <tr><td colspan="2" id="span-elem">Three-Four</td></tr>
</table>

Events
======
We can bind events to the elements in 3 ways,
1. With element attribute
2. With DOM-object property
3. Using addEventListener method

Handle events with element attribute
------------------------------------
<input id="b1" value="Click me" onclick="alert('Thanks!');" type="button"/>

Inside an event handler, this references the current element.

<button onclick="alert(this.innerHTML)">Click me to see me</button>

'event' contains the entire information about the event.

<button onclick="console.log(event)">Click me to see me</button>

Handle events with DOM-object property
--------------------------------------
<input id="myElement" type="button" value="Press me"/>
<script>
document.getElementById('myElement').onclick = function(event) {
    console.log('Thanks');
    console.log(event);
}
</script>

Handle events using addEventListener
------------------------------------
Ex: remove-event-listener.html

// Add event to element
elem.addEventListener(type, handler, false)

// Remove event to element
elem.removeEventListener(type, handler, false)

<script>
    document.getElementById("myDIV").addEventListener("mousemove", myFunction);

    function myFunction(event) {
        console.log(event);
        document.getElementById("demo").innerHTML = Math.random();
    }

    function removeHandler() {
        document.getElementById("myDIV").removeEventListener("mousemove", myFunction);
    }
</script>

mousedown
Triggered by an element when a mouse button is pressed down over it
mouseup
Triggered by an element when a mouse button is released over it
mouseover
Triggered by an element when the mouse comes over it
mouseout
Triggered by an element when the mouse goes out of it
mousemove
Triggered by an element on every mouse move over it.

click
Triggered by a mouse click: mousedown and then mouseup over an element
contextmenu
Triggered by a right-button mouse click over an element.
dblclick
Triggered by two clicks within a short time over an element

keydown
A key is pressed down.
keypress
A character key is pressed.
keyup
A key is released.

window events
-------------
onload
onunload

window.onload = function() {
  alert("Page loaded");
};

// window.onunload is working in IE. Not sure in Chrome etc.. 
window.onunload = function() {
  window.open("https://in.yahoo.com/"); 
};

Ex: win-events.html

Along with load and unload we have resize and scroll events also.

We have 'submit' event on form element. Also, focus, blur, change etc... events on form elements.

Event Propagation and Prevent default
-------------------------------------
Examples: event-propagation.html

// To prevent default action. Ex: Prevent navigation of <a> tag, form submission etc..
event.preventDefault();

// Capturing and bubling events.
An event contains 3 phases.
1. Capturing
2. Targeting
3. Bubling

Capturing: The event is first captured by the outermost element and propagated to the inner elements.
Html -> Body -> Form -> Div -> P

Targeting means traverse through the DOM and find Targeted element.

Bubling: When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.
P -> Div -> Form

event.stopPropagation(); // To prevent propagation.

AJAX
----
AJAX - Asynchronous Javascript And Xml

It's not a programming language. It's a technique to hit server and change webpage content without re-loading page.

function loadDoc() {
    var xhttp = new XMLHttpRequest();
    xhttp.open("GET", "http://localhost:3000/todos", true);
    xhttp.send();
    xhttp.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            document.getElementById("demo").innerHTML = this.responseText;
        }
    };
}

The onreadystatechange property specifies a function to be executed every time the status of the XMLHttpRequest object changes.
When readyState property is 4 and the status property is 200, the response is ready.

Different readyStates available are below,
0	UNSENT - Client has been created. open() not called yet.
1	OPENED - open() has been called.
2	HEADERS_RECEIVED - send() has been called, and headers and status are available.
3	LOADING	- Downloading; responseText holds partial data.
4	DONE - The operation is complete.

Ex: ajax folder

Timing methods
==============
Ex: timing.html

setTimeout, clearTimeOut
------------------------
setTimeout function is used to execute a function or some statements after some specified time.

var timeOutRef = setTimeout(function() {
  document.getElementById('demo1').innerText = "Text changed";
}, 3000);

function stop() {
  clearTimeout(timeOutRef);
}

The default timeout is 4ms. If we don't give the value it will take 4ms.(Browser delay)
setTimeout(function() {
  document.getElementById('demo1').innerText = "Text changed";
}); 

setInterval, clearInterval
--------------------------
setInterval function is used to execute a function or some statements repeatedly on specified time interval.

var i = 0;
var intervalRef = setInterval(function(){
  i++;
  document.getElementById('count').innerText = i;
}, 1000);

function stopCounting() {
  clearInterval(intervalRef);
}

localStorage
============
'localStorage' is a global object in javascript. We can access it by 'window.localStorage' or 'localStorage'.

localStorage is domain specific. We can't access localStorage of one domain from another domain.

We store the data as key, value pairs in localStorage. 

localStorage.setItem("key", "value");

localStorage.setItem("name", "John"); // To store data

var lastname = localStorage.getItem("name"); // To retrieve data

localStorage.removeItem("key"); // To remove data

Only store strings
------------------
If we store object in localStorage and trying to access it, we will get "[object Object]". So, we need to stringify the objects and store it in localStorage.

WRONG:
localStorage.setItem('user', {name: 'John', age: 25});
localStorage.getItem('user'); // "[object Object]"

CORRECT:
localStorage.setItem('user', JSON.stringify({name: 'John', age: 25}));
var user = localStorage.getItem('user'); // "{name: 'John', age: 25}"
user = JSON.parse(user); // {name: 'John', age: 25}

Exceptions
==========
new Error([message[, fileName[, lineNumber]]])

The Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur.

try {
  throw new Error('Whoops!');
} catch (e) {
  console.log(e.name + ': ' + e.message);
}

// Example function
function myFunc(a, b){
  try {
    if ( b == 0 ){
      throw( "Divide by zero error." ); 
    } else {
      var c = a / b;
    }
  } catch ( e ) {
    alert("Error: " + e );
  } finally {
    alert("Finally block will always execute!" );
  }
}

myFunc(10, 0);

Regular Expressions
===================
Regular expressions are used to perform pattern-matching.

var patt = /Hello/i

/Hello/i - is a regular expression. Note: It's not a string. No quotes around it.
Hello    - is pattern(used to perform search)
i        - is a modifier(modifies the search to be case-insensitive).
g        - global search. Don't stop at first match.

test() method
-------------
test() method is used to search pattern in given string. If string matched with pattern, test() will return true.

var str = "Hello world!";
var pattern = /Hello/;
var result = pattern.test(str); // True

var pattern = /hello/; 
var result = pattern.test(str); // False. Case sensitive search

var pattern = /hello/i;
var result = pattern.test(str); // True. Case insensitive search

var emailPattern = /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}$/g;
email = 'test@gmail.com';
emailResult = emailPattern.test(email);  // True
emailResult = emailPattern.test('test@');  // False

str.match() method
------------------
str.match() is a method available on strings, to check a pattern against a string.

var str = "Widget with id Widget";
str.match(/Widget/); // Search stops after first occurence
str.match(/Widget/g); // Returns an array with 2 elements
str.match(/widget/); // Returns null. Case sensitive search
str.match(/widget/ig); // Returns an array with 2 elements. Case in-sensitive global search

JavaScript Libraries
====================
- moment
- lodash / underscore js
- jquery

We can find libraries for the tasks like fileupload, generate excel, generate pdf etc..

NPM
===
npm init

npm install jquery
npm i jquery
npm install jquery --save
npm install jasmine --save-dev

npm install -g @angular/cli - Global installation

Specifying version in package.json
----------------------------------
"jquery": "*" - any version

"jquery": "latest" - latest version

"jquery": "1.x"
  or:
"jquery": "^1.0.0" ----> install the latest minor version. Upto 1.x.x but not 2.0.0
  - x is the highest minor/patch version here

"jquery": "~1.11"  -----> install the latest patch version. Upto 1.11.x but not 1.12.0
  - x is the highest patch version here

"@angular/core": "^6.0.0 || ^7.0.0 || ^8.0.0" -------> Any version of 6, 7 or 8.

semantic versiong calculator
----------------------------
https://semver.npmjs.com/

Browser Compatibility
---------------------
- We have many browsers. All the browsers don't behave in same way. Some features are not supported by few browsers.

https://caniuse.com is to verify the browser compatibility of html, css and javascript features.

Sites to Refer
==============
https://www.w3schools.com/

http://javascript.info/

Pass by value VS Pass by reference
==================================
Just a reminder that numbers, booleans, strings, null and undefined are primitive types. All primitive types are passed by value. Objects, arrays, and functions are also passed by value, but the value is a copy of a reference.

Specifically, when you pass an object (or array) you are (invisibly) passing a reference to that object, and it is possible to modify the contents of that object, but if you attempt to overwrite the reference it will not affect the copy of the reference held by the caller - i.e. the reference itself is passed by value:

function replace(ref) {
  ref = {}; // this code does _not_ affect the object passed
}

function update(ref) {
  ref.key = 'newvalue';  // this code _does_ affect the _contents_ of the object
}

var a = { key: 'value' };
replace(a);  // a still has its original value - it's unmodfied
update(a);   // the _contents_ of 'a' are changed

One function – one action
=========================
A function should do exactly what is suggested by its name, no more.
Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).

getAge – would be bad if it shows an alert with the age (should only get).

If the action is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.

Functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.

Functions == Comments

When to choose Function Declaration versus Function Expression?

As a rule of thumb, when we need to declare a function, the first to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.

That’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.

Shallow Copy VS Deep Copy
=========================
Shallow Copy 
- only copies the first level key and value pairs. Internal object and array references will be copied.
- Shallow copy create new object. But, copy the references of internal values.
- If we change the internal values of an object/array original object will be updated. Because, the reference of both are same.
- If we replace the value of entire object, it doesn't impact the original object.

var a = { count: 123, values: [1, 2, 3], user: { name: 'john', age: 25 }};

// Just duplicate a. Not a shallow copy also.
var b = a;
- Updating b.count will reflect change in a.count

// Creates a shallow copy
var c = Object.assign({}, a); // Object.assign method
var c = {...a}; // Spread operator
- Updating c.count doesn't change a.count. But, internal object changes will reflect a.
- Updating c.user.name or c.values[1] will update a object.
- The spread syntax and Object.assign() allow us to make only shallow copies of objects in JavaScript. Deeply nested values are in fact put there just as a reference to the source object.

Deep Copy
---------
- Creates entirely a new object. No reference copy.
- New references will be created in all the levels.
- Change on internal values of objects doesn't impact the original object.
- Write your own method by using recursion technique or get it from google.

// Below will simply create a deep copy
var c = {
  count: a.count,
  values: a.values,
  user: a. user
};

// For simple data structures we can use JSON.parse(JSON.stringify()) method for deep copy.
var c = JSON.parse(JSON.stringify(a));
- It will do deep copy. But, skip the functions and unserializable objects like Date object etc..
- A bit slow

// Use jQuery.extend method
var c = jQuery.extend({}, a); // Do a shallow copy
var c = jQuery.extend(true, {}, a); // Do a deep copy

// Use lodash
var c = _.clone(a); // Do a shallow copy
var c = _.cloneDeep(a); // Do a deep copy

Serialization and Deserialization
=================================
- Serializable means that the data can be converted to pure text without losing information.
- Serialization converts an in-memory data structure to a value that can be stored or transferred.
- JSON.stringify() serialize the object.
- JSON.parse() deserialize the object.
- JSON don't contain the functions. It can serialize strings, numbers, objects, arrays, booleans and null.
- JSON.stringify() will remove the undefined properties from object.
- Javascript class instances are not fully serializable. We loose the methods.
- Javascript Date object is non serializable.
- Cyclic depedent data can't be serialized.
  const data = { foo: 'bar' };
  data.self = data;
  const data2 = JSON.parse(JSON.stringify(data)); // TypeError: Converting circular structure to JSON

- Non-ASIIC characters can't be transimiited in url. 
- So, encodeURI and decodeURI methods will help us to serialize and deserialize non-ASIIC characters.
  var uri = "my test.asp?name=ståle&car=saab";
  var res = encodeURI(uri); // my%20test.asp?name=st%C3%A5le&car=saab
  decodeURI(res); // my test.asp?name=ståle&car=saab

POJO - Plain Old JavaScript Object
==================================
var pojo = new Object(null);
- It don't even have inherited properties of Object class as well.
- POJO's don't contain any inherited properties.
- Contains the data of the self object.

DOM - Shadow DOM - Virtual DOM
==============================
DOM - Document Object Model is an object-based representation of an HTML document and an interface to manipulating that object.

The shadow DOM can be thought of as a “lite” version of the DOM.It is also an object-based representation of HTML elements, but not of a full standalone document. Instead, the shadow DOM allows us to separate our DOM into smaller, encapsulated bits that can be used across HTML documents.

Querying and updaing the DOM will become an expensive operation as the application size grows.

The virtual DOM was created to solve these problems of needing to frequently update the DOM in a more performant way. 

Unlike the DOM or the shadow DOM, the virtual DOM isn't an official specification, but rather a new method of interfacing with the DOM.

A virtual DOM can be thought of as a copy of the original DOM. This copy can be frequently manipulated and updated, without using the DOM APIs. Once all the updates have been made to the virtual DOM, we can look at what specific changes need to be made to the original DOM and make them in a targetted and optimised way.

Shadow meaning - follow and observe (someone) closely and secretly.
Virtual meaning - being actually same in almost every respect.

A virtual DOM is just a regular Javascript object.

The object representation of actual html document can be think as virtual DOM. i.e 'document' object

Since it is a plain Javascript object, we can manipulate it freely and frequently without touching the actual HTML document until we need to.

Instead of using one object for the entire object, it is more common to work with small sections of the virtual DOM. For example, we may work on a list component, which would corespond to our unordered list element.

const list = {
  tagName: "ul",
  attributes: { "class": "list" },
  children: [
    {
      tagName: "li",
      attributes: { "class": "list__item" },
      textContent: "List item"
    }
  ]
};

If we want to add another element to the list just copy the above list object and add it.

const copy = {
  tagName: "ul",
  attributes: { "class": "list" },
  children: [
      {
          tagName: "li",
          attributes: { "class": "list__item" },
          textContent: "List item one"
      },
      {
          tagName: "li",
          attributes: { "class": "list__item" },
          textContent: "List item two"
      }
  ]
};

This copy is used to create what is called a “diff” between the original virtual DOM, in this case the list, and the updated one. A diff could look something like this:

const diffs = [
  {
      newNode: { /* new version of list item one */ },
      oldNode: { /* original version of list item one */ },
      index: /* index of element in parent's list of child nodes */
  },
  {
      newNode: { /* list item two */ },
      index: { /* */ }
  }
]

This diff provides instructions for how to update the actual DOM. Once all the diffs are collected, we can batch changes to the DOM, making only the updates that are needed.

For example we could loop through each diff and either add a new child or update an old one depending on what the diff specifies.

const domElement = document.getElementsByClassName("list")[0];

diffs.forEach((diff) => {
  const newElement = document.createElement(diff.newNode.tagName);
  /* Add attributes ... */
  
  if (diff.oldNode) {
      // If there is an old version, replace it with the new version
      domElement.replaceChild(diff.newNode, diff.index);
  } else {
      // If no old version exists, create a new node
      domElement.appendChild(diff.newNode);
  }
});

It's more common to work with the virtual DOM via a framework, rather than interfacing with it directly. 

Frameworks such as React and Vue use the virtual DOM concept to make more performant updates to the DOM. 

As frameworks uses the virtual DOM, even though we are re-rendering the entire template, only the parts that actually change are updated.

React and Vue are using Virtual DOM and Angular use direct DOM rendering system. Angular has change detection that detects changes to the model and only updates the parts of the DOM that need to be changed according to the model changes.

Shadow DOM is used to encapsulate the styles of an element. Ex: <input type="range">

<input type="range">
  #shadow-root
  <div>
    <div pseudo="-webkit-slider-runnable-track" id="track">
      <div id="thumb"></div>
    </div>
  </div>

What you see under #shadow-root is called “shadow DOM”.
We can’t get built-in shadow DOM elements by regular JavaScript calls or selectors. These are not regular children, but a powerful encapsulation technique.

It allows a component to have its very own “shadow” DOM tree, that can’t be accidentally accessed from the main document, may have local style rules, and more.

Complex browser controls are created and styled using Shadow DOM concept.

Reference: https://bitsofco.de/understanding-the-virtual-dom/

Style Guide
===========
https://google.github.io/styleguide/jsguide.html

Web Components
==============
- class MyElement extends HTMLElement { }
    - customElements.define("my-element", MyElement);
    
- litcomponents
	- LitElement is a base class for creating fast, lightweight web components.
	- To create the custom elements easily we can use LitElement

- https://custom-elements-everywhere.com/
  - Test suite to run agains each framework to figureout web component capabilities of frameworks
  - React failing some tests, Vue is passing all.

Web Worker
==========
Web Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. 

The advantage of this is that laborious processing(resource intensive processing) can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.

A worker is an object created using a constructor (e.g. Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.

if (typeof(Worker) !== "undefined") {
  if (typeof(w) == "undefined") {
    w = new Worker("demo_workers.js");
  }
  w.onmessage = function(event) {
    document.getElementById("result").innerHTML = event.data;
  };
}

// demo_workers.js
var i = 0;
function timedCount() {
  i = i + 1;
  postMessage(i);
  setTimeout("timedCount()",500);
}
timedCount();

postMessage() method - which is used to post a message back to the HTML page.
w.onmessage -  "onmessage" event listener to the web worker receives the posted data

Since web workers are in external files, they do not have access to the following JavaScript objects:
  - The window object
  - The document object
  - The parent object

Ex: web-worker.html
  - If we open the above file using file protocol in browser, it can't load the demo_workers.js file
  - Install 'serve' npm module globally to run simple server and run 'serve' command in examples folder

Debugging web workers
  - Usually web worker scripts doesn't appear under 'sources' tab -> domain name
  - While web worker is running web worker file process appears under 'sources' tab. We can open the script file and debug

Service Worker
==============


Object Properties Configuration
===============================
- object property is a more flexible and powerful

Property Flags
--------------
Object properties, besides a value, have three special attributes (so-called “flags”)
  - writable – if true, the value can be changed, otherwise it’s read-only.
  - enumerable – if true, then listed in loops, otherwise not listed.
  - configurable – if true, the property can be deleted and these attributes can be modified, otherwise not.

When we create a property “the usual way”, all of them are true. But we also can change them anytime.

Generally the flags do not show up. The method Object.getOwnPropertyDescriptor allows to query the full information about a property.

> let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);

The returned value is called “property descriptor” object: it contains the value and all the flags.

let user = {
  name: "John"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
console.log(descriptor);

// Result
{
  "value": "John",
  "writable": true,
  "enumerable": true,
  "configurable": true
}

To change the flags, we can use Object.defineProperty.
> Object.defineProperty(obj, propertyName, descriptor)
  - If the property exists, defineProperty updates its flags. 
  - Otherwise, it creates the property with the given value and flags.
  - If a flag is not supplied, it is assumed false.

> Create a property 'name' with all falsy flags:

  let user = {};
  Object.defineProperty(user, "name", {
    value: "John",
  });
  let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
  console.log(descriptor);

  // Result 
  {
    "value": "John",
    "writable": false,
    "enumerable": false,
    "configurable": false
  }

> Override the existing value, flag with different configuration is not possible if it is already defined with 'defineProperty'

  Object.defineProperty(user, "name", {
    value: "Doe",
    "enumerable": true,
  }); // Uncaught TypeError: Cannot redefine property: name

> If a property is naturally defined, then we can override the value and flags with 'defineProperty'
  let user = { name: "John" };
  Object.defineProperty(user, "name", {
    value: "Doe",
    writable: false
  });
  let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
  console.log(descriptor);

Non-writable
------------
  let user = { name: "John" };
  Object.defineProperty(user, "name", {
    writable: false
  });

  Now the name became non-writable.

  user.name = 'Pete'; 
    - Don't throw any error in normal mode. But, value won't update. Still user.name is 'John'.
    - Throw error in strict mode.
      - TypeError: Cannot assign to read only property 'name' of object

Non-enumerable
--------------
  - Prevent properties from loops.

  let user = {
    name: "John",
    toString() {
      return this.name;
    }
  };
  for (let key in user) console.log(key); // name, toString

  Object.defineProperty(user, "toString", {
    enumerable: false
  });
  for (let key in user) console.log(key); // name
  
  Non-enumerable properties are also excluded from Object.keys:
  console.log(Object.keys(user)); // name

Non-configurable
----------------
  - The non-configurable flag (configurable:false) is sometimes preset for built-in objects and properties.
  - A non-configurable property can’t be deleted, its attributes can’t be modified.
  - For instance, Math.PI is non-writable, non-enumerable and non-configurable:

  let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');
  console.log(descriptor); 
  // {value: 3.141592653589793, writable: false, enumerable: false, configurable: false}

  So, a programmer is unable to change the value of Math.PI or overwrite it.
  Math.PI = 3; // Error, because it has writable: false

  We cannot change it back with defineProperty.
  Object.defineProperty(Math, "PI", { writable: true }); // TypeError: Cannot redefine property: PI

  ** Please note: configurable: false prevents changes of property flags and its deletion, while allowing to change its value.

  let user = {
    name: "John"
  };

  Object.defineProperty(user, "name", {
    configurable: false
  });

  user.name = "Pete"; // works fine
  delete user.name; // Error

  The only attribute change possible: writable true → false. That’s a minor exception about changing flags.
  writable false -> true is not possible

  let user = {
    name: "John"
  };

  Object.defineProperty(user, "name", {
    writable: false, // true -> false possible. false -> true not possible
    configurable: false
  });

  // won't be able to change user.name or its flags
  // all this won't work:
  user.name = "Pete";
  delete user.name;
  Object.defineProperty(user, "name", { value: "Pete" });

Object.defineProperties
-----------------------
  - To define multiple properties at a time

  Object.defineProperties(user, {
    name: { value: "John", writable: false },
    surname: { value: "Smith", writable: false },
  });

Object.getOwnPropertyDescriptors
--------------------------------
  - To get all property descriptors at once
  - Together with Object.defineProperties it can be used as a “flags-aware” way of cloning an object:
    let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));

  - Normal cloning techniques don't copy the object flags
    for (let key in user) {
      clone[key] = user[key]; // only copy key-value. 
    }

Sealing an object globally
--------------------------
  - Property descriptors work at the level of individual properties
  - There are also methods that limit access to the whole object

  Object.preventExtensions(obj) & Object.isExtensible(obj)
  --------------------------------------------------------
    - Forbids the addition of new properties to the object

    'use strict';
    const object1 = {};
    Object.preventExtensions(object1);
    console.log(Object.isExtensible(object1)); // false
    object1.name = 'john'; // TypeError: Cannot add property name, object is not extensible

    - In normal mode, it don't throw error. Though, it don't add property to object1.

    - By using Object.defineProperty also we can't add value for extension prevent objects
    'use strict';
    const object1 = {};
    Object.preventExtensions(object1);
    Object.defineProperty(object1, 'property1', {
      value: 42
    }); // TypeError: Cannot add property name, object is not extensible

    Object.seal(obj) & Object.isSealed(obj)
    ---------------------------------------
      - Forbids adding/removing of properties. Sets configurable: false for all existing properties.
      - Allow to update the values.

      const object1 = {
        property1: 42
      };

      Object.seal(object1);
      object1.property1 = 33;
      console.log(object1.property1); // 33

      delete object1.property1; // cannot delete when sealed
      console.log(object1.property1); // 33

      object1.property2 = 44; // new property2 not added
      console.log(Object.isSealed(object1)); // true

    Object.freeze(obj) & Object.isFrozen(obj)
    -----------------------------------------
      - Forbids adding/removing/changing of properties. 
      - Sets configurable: false, writable: false for all existing properties.

      const obj = {
        prop: 42
      };
      Object.freeze(obj);
      obj.prop = 33; // Throws an error in strict mode
      console.log(obj.prop); // 42
      console.log(Object.isFrozen(obj)); // true

Property getters and setters
----------------------------
  - There are two kinds of object properties.

    1. Data properties
      - All properties that we’ve been using until now. Ex: name, age etc...

    2. Accessor properties
      - Functions that execute on getting and setting a value. Getters and Setters.
      - Look like regular properties to an external code
      - Accessor properties are represented by “getter” and “setter” methods.
      - In an object literal they are denoted by get and set

      let obj = {
        get propName() {
          // getter, the code executed on getting obj.propName
        },

        set propName(value) {
          // setter, the code executed on setting obj.propName = value
        }
      };

      let user = {
        name: "John",
        surname: "Smith",

        get fullName() {
          return `${this.name} ${this.surname}`;
        }
      };
      console.log(user.fullName); // John Smith
      user.fullName = "Test"; // Error will occur in strict mode. 
      // fullName has only a getter. so, value don't update
      
  - We don’t call user.fullName as a function, we read it normally: the getter runs behind the scenes.

  Accessor descriptors
  --------------------
    - Descriptors for accessor properties are different from those for data properties.
    - For accessor properties, there is no value or writable, but instead there are get and set functions.
      - get – a function without arguments, that works when a property is read,
      - set – a function with one argument, that is called when the property is set,
      - enumerable – same as for data properties,
      - configurable – same as for data properties.
    
    let descriptor = Object.getOwnPropertyDescriptor(user, 'fullName');
    console.log(descriptor); // {set: undefined, enumerable: true, configurable: true, get: ƒ}

    - set object accessor properties through Object.defineProperty

      let user = {
        name: "John",
        surname: "Smith"
      };

      Object.defineProperty(user, 'fullName', {
        get() {
          return `${this.name} ${this.surname}`;
        },

        set(value) {
          [this.name, this.surname] = value.split(" ");
        }
      });

    - A property can be either an accessor (has get/set methods) or a data property (has a value), not both.

      // TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute
      Object.defineProperty({}, 'prop', {
        get() {
          return 1
        },
        value: 2
      });

Proxy and Reflect
=================
  - A Proxy object wraps another object and intercepts operations, like reading/writing properties and others
  
  let proxy = new Proxy(target, handler);
    - target: is an object to wrap, can be anything, including functions.
    - handler: proxy configuration. An object with traps.
        - get trap for reading a property of target, set trap for writing a property into target. etc...

  - For operations on proxy, if there’s a corresponding trap in handler, then it runs, and the proxy has a chance to handle it, otherwise the operations are forwarded to target.

  - a proxy without any traps

    let target = {};
    let proxy = new Proxy(target, {}); // empty handler
    proxy.test = 5;
    console.log(target.test); // 5, the property appeared in target!
    console.log(proxy.test); // 5, we can read it from proxy too (2)

  - For operations on objects there are 'internal methods', which we can't invoke directly. For instance, [[Get]] to read the property and [[Set]] to write an object property. Proxy traps intercept invocations of these methods. 

  - For every internal method, there’s a trap.
    
    Internal Method         Handler Method            Triggers when…
    [[Get]]	                get	                      reading a property
    [[Set]]	                set	                      writing to a property
    [[HasProperty]]	        has	                      'in' operator
    [[Delete]]	            deleteProperty	          delete operator
    [[Call]]	              apply	                    function call
    [[Construct]]	          construct	                new operator
    [[GetPrototypeOf]]	    getPrototypeOf	          Object.getPrototypeOf
    [[SetPrototypeOf]]	    setPrototypeOf	          Object.setPrototypeOf
    [[IsExtensible]]	      isExtensible	            Object.isExtensible
    [[PreventExtensions]]	  preventExtensions	        Object.preventExtensions
    [[DefineOwnProperty]]	  defineProperty	          Object.defineProperty, Object.defineProperties
    [[GetOwnProperty]]	    getOwnPropertyDescriptor	Object.getOwnPropertyDescriptor, for..in, 
                                                      Object.keys/values/entries
    [[OwnPropertyKeys]]	    ownKeys	                  Object.getOwnPropertyNames, Object.getOwnPropertySymbols, 
                                                      for..in, Object.keys/values/entries
get trap
--------
  - get(target, property, receiver)
      - target: target object
      - property: property name
      - receiver: receiver is the object that’s going to be used as this in its call. Usually that’s the proxy object itself 
  - usually when one tries to get a non-existing array item, they get undefined, but we’ll wrap a regular array into the proxy that traps reading and returns 0 if there’s no such property.

    let numbers = [0, 1, 2];
    numbers = new Proxy(numbers, {
      get(target, prop) {
        if (prop in target) {
          return target[prop];
        } else {
          return 0; // default value
        }
      }
    });
    console.log( numbers[1] ); // 1
    console.log( numbers[123] ); // 0 (no such item)

  - Please note how the proxy overwrites the variable:
    numbers = new Proxy(...);
    The proxy should totally replace the target object everywhere. No one should ever reference the target object after it got proxied. Otherwise it’s easy to mess up.
  
set trap
--------
  - set(target, property, value, receiver)
  - The set trap should return true if setting is successful, and false otherwise (triggers TypeError)
  - Let's build an array which only accepts numbers as it's values, otherwise throw an error.

    let numbers = [];
    numbers = new Proxy(numbers, {
      set(target, prop, val) {
        if (typeof val == 'number') {
          target[prop] = val;
          return true;
        } else {
          return false;
        }
      }
    });
    numbers.push(1); // added successfully
    numbers.push(2); // added successfully
    numbers.push("test"); // TypeError ('set' on proxy returned false)

  - Please refer javascript.info docs for other kind of traps

Reflect
-------
  - Reflect is a built-in object that simplifies creation of Proxy.
    - Kind of utility to solve some unique problems in creation of proxies.
    - Using Reflect we can invoke the internal methods indirectly. 
    - Reflect methods are minimal wrappers around the internal methods like [[Get]], [[Set]], etc...
  - Reflect.get(obj, prop)
    Reflect.set(obj, prop, value)
    Reflect.deleteProperty(obj, prop)
    Reflect.construct(F, value)
    etc.....
  - For every internal method, trappable by Proxy, there’s a corresponding method in Reflect, with the same name and arguments as the Proxy trap.
  - We can use Reflect to forward an operation to the original object.
  - Ex: Transparently forward reading/writing operations to the object using Reflect.

    let user = {
      name: "John",
    };
    user = new Proxy(user, {
      get(target, prop, receiver) {
        console.log(`GET ${prop}`);
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, val, receiver) {
        console.log(`SET ${prop}=${val}`);
        return Reflect.set(target, prop, val, receiver);
      }
    });
    let name = user.name; // shows "GET name"
    user.name = "Pete"; // shows "SET name=Pete"

  - If a trap wants to forward the call to the object, it’s enough to call Reflect.<method> with the same arguments.
  - In most cases we can do the same without Reflect, for instance, reading a property Reflect.get(target, prop, receiver) can be replaced by target[prop]. There are important differences though.

    let user = {
      _name: "Guest",
      get name() {
        return this._name;
      }
    };

    let userProxy = new Proxy(user, {
      get(target, prop, receiver) {
        return target[prop]; // (*) target = user
      }
    });

    let admin = {
      __proto__: userProxy,
      _name: "Admin"
    };

    // Expected: Admin
    console.log(admin.name); // outputs: Guest (?!?)

    - Reading admin.name should return "Admin", not "Guest"!
    - while accessing getter method name, this = target, target is 'user'
    - To fix such situations, we need receiver, the third argument of get trap. It keeps the correct 'this' to be passed to a getter. In our case that’s admin.

    let user = {
      _name: "Guest",
      get name() {
        return this._name;
      }
    };

    let userProxy = new Proxy(user, {
      get(target, prop, receiver) { // receiver = admin
        return Reflect.get(target, prop, receiver); // (*)
      }
    });


    let admin = {
      __proto__: userProxy,
      _name: "Admin"
    };

    console.log(admin.name); // Admin

    - Now receiver that keeps a reference to the correct this (that is admin), is passed to the getter using Reflect.get in the line (*).
    - We can rewrite the trap even shorter:
      get(target, prop, receiver) {
        return Reflect.get(...arguments);
      }

Revocable proxies
-----------------
  - A revocable proxy is a proxy that can be disabled.
  - Let’s say we have a resource, and would like to close access to it any moment. What we can do is to wrap it into a revocable proxy, without any traps. Such a proxy will forward operations to object, and we can disable it at any moment.

  let object = {
    data: "Valuable data"
  };

  let {proxy, revoke} = Proxy.revocable(object, {});

  // pass the proxy somewhere instead of object...
  console.log(proxy.data); // Valuable data

  // later in our code
  revoke();

  // the proxy isn't working any more (revoked)
  console.log(proxy.data); // Error

Browser hashchange events
-------------------------
window.addEventListener('hashchange', (event) => {
  console.log('Hashchange event', event);
});

Ex: hash-page.html

Web History API
===============
The Web History API provides easy methods to access the windows.history object.

window.history object contains the URLs visited by the user.

The back() method loads the previous URL in the windows.history list.
window.history.back();

It is the same as clicking the "back arrow" in your browser.

The go() method loads a specific URL from the history list:
window.history.go(-2);

window.history.length
  - Returns the number of URLs in the history list

forward()
  - Loads the next URL in the history list

Location API
============
The window.location object can be used to get the current page details and to redirect the browser to a new page.
  
Location can be accessed using window.location, document.location or just with 'location'.

window.location.href returns the href (URL) of the current page
window.location.hostname returns the domain name of the web host
window.location.pathname returns the path and filename of the current page
window.location.protocol returns the web protocol used (http: or https:)
window.location.assign() loads a new document

location.search - returns the search parameters from the url
location.hash - returns the hash from the url

Cache API
=========
The Cache API provides a mechanism for storing network requests and retrieving their corresponding responses during run-time. It can be used in the absence of an internet connection and this makes it integral to the building of progressive web applications.

- The Cache API allows Service Workers to have a control over resources(HTML pages, CSS, JavaScript files, images, JSON, etc) to be cached.

const newCache = await caches.open('new-cache');

- newCache.add('/cats.json')

- const urls = ['pets/cats.json', 'pets/dogs.json'];
  newCache.addAll(urls);

// retrieve a new response
const request = '/cats.json';
const response = await newCache.match(request);

- newCache.put('./cats.json')

- const request = '/cats.json';
  newCache.delete(request);

// Delete the entire cache from device
- caches.delete('new-cache');

Mutation Observer
=================
MutationObserver is a built-in object that observes a DOM element and fires a callback when it detects a change.

DOM element change observer.

For example, one element is modified from somewhere, from other script which we don't have control(ex: ads script, third party script etc...). If we want to respond for such kind of changes in the DOM, we can observe changes on elements and respond using MutationObserver.

Syntax:
let observer = new MutationObserver(callback);
observer.observe(node, config);

Refer: examples/mutation-observer.html

const languageObserver = new MutationObserver(mutationRecord => {
  console.log("Language Changed to", mutationRecord[0].target.lang);
  // We can invoke the translate service here to translate the page without reloading
});

languageObserver.observe(document.documentElement, {
  attributes: true,
  attributeOldValue: true
});

We can observe changes in childList, subtree, attributes etc....

Event loop: microtasks and macrotasks
=====================================
Broswer javascript and Node.js execution flow depends on the event loop.

Event loop is an endless loop of javascript engine, executes the tasks and wait for the next tasks. It has a queue of tasks and tasks from the queue are processed on “first come – first served” basis.

When the javascript engine waiting for tasks(i.e ideal) the CPU consumption is almost zero. JavaScript engine does nothing most of the time, initially executes the script and wait for the events to occur and get tasks.

Rendering never happens while the engine executes a task. Changes to the DOM are painted only after the task is complete. If a task takes too long, the browser can’t do other tasks, such as processing user events. So after a time, it raises an alert like “Page Unresponsive”, suggesting killing the task with the whole page. 

'for' loop of 100 Million numbers will take 3-4 seconds. In the mean time no user events execute. Browser go hang.
If we can split the taks into small pieces using setTimeout (counting 1-1000, 1001-2000 so on...) then browser don't hang.

<div id="progress"></div>

<script>
  let i = 0;
  function count() {
    // do a piece of the heavy job (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }
  }
  count();
</script>

Splitting a CPU-hungry task into parts doesn’t block the user interface.

As per the V8 javascript engine there are two kind of taks.

Macrotasks: script tag/script file execution, setTimeout, events like click, mousemove etc...

microtasks: Microtasks comes only from our code. They are usually created by promises: an execution of .then/catch/finally handler becomes a microtask. Microtasks are used “under the cover” of await as well, as it’s another form of promise handling.

ECMA standard specifies an internal queue PromiseJobs, more often referred to as the “microtask queue” (V8 term).

when a promise is ready, its .then/catch/finally handlers are put into the queue; they are not executed yet. When the JavaScript engine becomes free from the current code, then it executes microtasks.

let promise = Promise.resolve();
promise.then(() => alert("promise done!")); // This alert shows next to below(microtask)
alert("code finished"); // this alert shows first(Macrotask)

There’s also a special function queueMicrotask(func) that queues func for execution in the microtask queue.

Immediately after every Macrotask, the engine executes all tasks from microtask queue and then render.

Execution order:
(Macrotask1 - All microtasks - Render) -> (Macrotask2 - All microtasks - Render) -> etc...
Img: eventloop.png

There’s no UI event or network event handling between microtasks: they run immediately one after another and then UI renders.

For long heavy calculations that shouldn’t block the event loop, we can use Web Workers. That’s a way to run code in another, parallel thread. Web Workers can exchange messages with the main process, but they have their own variables, and their own event loop.

Web Workers do not have access to DOM, so they are useful, mainly, for calculations, to use multiple CPU cores simultaneously.

Promise, Async / Await
======================
// Promise constructor 
let promise = new Promise(function(resolve, reject) {
  // executor (the producing code)
  // send a network request and resolve when it finish
});

The function passed to new Promise is called the executor. 

resolve and reject are callbacks provided by JavaScript itself. 
resolve(value) — if the job is finished successfully, with result value.
reject(error) — if an error has occurred, error is the error object.

The promise object returned by the new Promise constructor has two internal properties(state, result) and other methods,
state: initially "pending", change to "fulfilled" on 'resolve' , change to "rejected" on 'reject' is called.
result: initially undefined, change to 'value' when resolve(value), 'error' when reject(error) is called.

So, executor moves a promise to either fulfilled or rejected state from pending state.

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done"), 1000);
}); // value will be 'done' and state will be 'fulfilled'

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
}); // value will be 'error' and state will be 'rejected'

A promise that is either resolved or rejected is called “settled”, as opposed to an initially “pending” promise.

The properties 'state' and 'result' of the Promise object are internal. We can’t directly access them. We can use the methods .then/.catch/.finally for that. 

Using then and catch consumers can subscribe to the results of promise executor.

promise.then(
  function(result) { /* handle a successful result */ },
  function(error) { /* handle an error */ }
);

If the promise is fulfilled then success handler will run and error handler will skip. vice-versa.

If we’re interested only in successful completions, then we can provide only one function argument to .then:
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // shows "done!" after 1 second

If we’re interested only in errors, then we can use null as the first argument: 
promise.then(null, function(error) { /* handle an error */ });

Or we can use .catch() as well.

.catch(f)
---------
// .catch(f) is the same as promise.then(null, f)
promise.catch((error) => { /* handle an error */ });

.catch() catch the error of promise and errors from then() method also.
promise.then((result) => {
  console.log(result);
  return x+result;
}).catch(error => {
  console.log(error);
}); // catch will execute with ReferenceError: x is not defined. An error from then.

promise.then(f1, f2); // Here f2 can handle only promise errors
promise.then(f1).catch(f2); // Here f2 can hanlde errors from both promise and then() block

.finally()
----------
When the promise is settled: be it resolve or reject, .finally(f) will run. It always run.

.finally(f) is used to perfom cleanup like stopping loader etc...

A finally handler has no arguments. In finally we don’t know whether the promise is successful or not.

Example delay() method code,
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(3000).then(() => alert('runs after 3 seconds'));

Promise chaining
----------------
Call to a .then returns a new promise, so that we can call the next .then on it.
When a handler returns a value, it becomes the result of that promise, so the next .then is called with it.

*** Anything returned from .then() is wrapped into a promise, and promise is returned from .then() ***
This helps the chaining. Also, we can manually create the promises in .then() and return.

To be precise, a handler may return not exactly a promise, but a so-called “thenable” object – an arbitrary object that has a method .then. It will be treated the same way as a promise.

// This is promise chaining
new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000); 
}).then(function(result) {
  alert(result); // 1
  return result * 2;
}).then(function(result) {
  alert(result); // 2
  return result * 2;
}).then(function(result) {
  alert(result); // 4
  return result * 2;
});

// This is not promise chaining. It is just several handlers to one promise.
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

Returning promise from .then:
A handler, used in .then(handler) may create and return a promise.
In that case further handlers wait until it settles, and then get its result.

new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
}).then(function(result) {
  alert(result); // 1
  return new Promise((resolve, reject) => { // (*)
    setTimeout(() => resolve(result * 2), 1000);
  });
}).then(function(result) { // (**)
  alert(result); // 2
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });
}).then(function(result) {
  alert(result); // 4
});

Returning promises allows us to build chains of asynchronous actions.

// Chaining example with fetch
fetch('/article/promise-chaining/user.json')
  .then(response => response.json()) // response.json() parses the response to json
  .then(user => alert(user.name)); // iliakan, got user name

// Chaining example with fetch, doing series of network requests
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);
    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .then(githubUser => alert(`Finished showing ${githubUser.name}`));
  .catch(error => alert(error.message));

If a .then handler returns a promise, the rest of the chain waits until it settles.

Error handling
--------------
When a promise rejects, the control jumps to the closest rejection handler. The .catch doesn’t have to be immediate. It may appear after one or maybe several .then.

The code of a promise executor and promise handlers has an "invisible try..catch" around it. If an exception happens, it gets caught and treated as a rejection.

The "invisible try..catch" around the executor automatically catches the error and turns it into rejected promise.

.catch at the end of the chain is similar to try..catch. We may have as many .then handlers as we want, and then use a single .catch at the end to handle errors in all of them.

If we throw inside .catch, then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the next closest successful .then handler.

// the execution: catch -> catch
new Promise((resolve, reject) => {
  throw new Error("Whoops!");
}).catch(function(error) { // (*)
  if (error instanceof URIError) {
    // handle it
  } else {
    alert("Can't handle such error");
    throw error; // throwing this or another error jumps to the next catch
  }
}).then(function() {
  /* doesn't run if error is not handled. Control goes to next catch */
  /* This will run if error is handled in above catch */
}).catch(error => { // (**)
  alert(`The unknown error has occurred: ${error}`);
  // don't return anything => execution goes the normal way
});

If a promise is failed for some error and it's not caught at promise level, we can catch such errors using the event unhandledrejection:

new Promise(function() {
  noSuchFunction(); // Error here (no such function)
}).then(() => {}); // without .catch at the end!

window.addEventListener('unhandledrejection', function(event) {
  // the event object has two special properties:
  alert(event.promise); // [object Promise] - the promise that generated the error
  alert(event.reason); // Error: Whoops! - the unhandled error object
});

.catch() can handle only synchronous errors. It can't hadle errors generate by asynchronous code.

new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert); // not caught

Promise API
-----------
There are 6 static methods in the Promise class. 

Promise.all
-----------
we want many promises to execute in parallel and wait until all of them are ready.

Promise.all takes an iterable (usually, an array of promises) and returns a new promise, resolved with array of their results.

let promise = Promise.all(iterable);

Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(results => console.log(results)); // [1, 2, 3]

If any of the promises is rejected, the promise returned by Promise.all immediately rejects with that error. In case of an error, other promises are ignored.

Promise.all does nothing to cancel them, as there’s no concept of “cancellation” in promises. We can use AbortController on fetch to cancel the network requests.

Promise.all(iterable) allows non-promise “regular” values in iterable

Normally, Promise.all(...) accepts an iterable (in most cases an array) of promises. But if any of those objects is not a promise, it’s passed to the resulting array “as is”.

Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2,
  3
]).then(alert); // 1, 2, 3

Promise.allSettled
------------------
Promise.all rejects as a whole if any promise rejects. That’s good for “all or nothing” cases, when we need all results successful to proceed:

Promise.allSettled just waits for all promises to settle, regardless of the result. The resulting array has:
{status:"fulfilled", value:result} for successful responses,
{status:"rejected", reason:error} for errors.

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
.then(results => { // (*)
  results.forEach((result, num) => {
    if (result.status == "fulfilled") {
      alert(`${urls[num]}: ${result.value.status}`);
    }
    if (result.status == "rejected") {
      alert(`${urls[num]}: ${result.reason}`);
    }
  });
});

Promise.race
------------
Similar to Promise.all, but waits only for the first settled promise and gets its result (or error).

Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1

After the first settled promise “wins the race”, all further results/errors are ignored.

Promise.any
-----------
Similar to Promise.race, but waits only for the first fulfilled promise and gets its result. 

If the first promise rejected then ignore the error and wait for the next one.

Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1

If all are rejected, then return an AggregateError,

Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ouch!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Error!")), 2000))
]).catch(error => {
  console.log(error.constructor.name); // AggregateError
  console.log(error.errors[0]); // Error: Ouch!
  console.log(error.errors[1]); // Error: Error!
});

Promise.resolve
---------------
Promise.resolve(value) creates a resolved promise with the result value.

let promise = Promise.resolve(value);

It is same as,
let promise = new Promise(resolve => resolve(value));

Promise.reject
--------------
Promise.reject(error) creates a rejected promise with error.

let promise = Promise.reject(new Error('Whoops!'));

It is same as,
let promise = new Promise((resolve, reject) => reject(new Error('Whoops!')));

Async/await
-----------
async/await is a special syntax to work with promises in more convenient way.

async function always returns a promise. Returned values are wrapped in a resolved promise automatically.

async function f() {
  return 1;
}

f().then(alert); // 1

We could explicitly return a promise, which would be the same:
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1

So, async ensures that the function returns a promise, and wraps non-promises in it.

await works only inside async functions. 

await makes JavaScript wait until that promise settles and returns its result.

async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait until the promise resolves (*)
  alert(result); // "done!"
}

f();

The function execution pauses at await and get the result, then further execution will happen. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.

It’s just a more elegant syntax of getting the promise result than promise.then. And, it’s easier to read and write.

async function showAvatar() {

  // read our JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // read github user
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // show the avatar
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // wait 3 seconds
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();

showAvatar().then(user => console.log(user));

Modern browsers allow top-level await in modules,
// we assume this code runs at top level, inside a module
let response = await fetch('/article/promise-chaining/user.json');
let user = await response.json();
console.log(user);

// In old browsers, wrap in anonymous async function
(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
})();

In real situations, the promise may take some time before it rejects. In that case there will be a delay before await throws an error.

We can catch that error using try..catch, the same way as a regular throw:

async function f() {
  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}
f();

If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected.

async function f() {
  let response = await fetch('http://no-such-url');
}

// f() becomes a rejected promise
f().catch(alert); // TypeError: failed to fetch // (*)

Fetch
=====
A typical fetch request consists of two await calls:

let response = await fetch(url, options); // resolves with response headers
let result = await response.json(); // read body as json

Or, without await:

fetch(url, options)
  .then(response => response.json())
  .then(result => /* process result */)

Response properties:
  - response.status – HTTP code of the response,
  - response.ok – true if the status is 200-299.
  - response.headers – Map-like object with HTTP headers.

Response body is a readable stream. We can read only once.
  - response.text() – return the response as text,
  - response.json() – parse the response as JSON object,

Fetch options so far:
  - method – HTTP-method,
  - headers – an object with request headers (few headers are not allowed to send),
  - body – the data to send (request body)


The fetch method allows to track download progress.

Please note: there’s currently no way for fetch to track upload progress. For that purpose, please use XMLHttpRequest.

using AbortController we can abort the network call,

let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});

controller.abort();

Full list of all possible fetch options with their default values and alternative values,

let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, etc.
  headers: {
    // the content type header value is usually auto-set
    // depending on the request body
    "Content-Type": "text/plain;charset=UTF-8"
  },
  body: undefined // string, FormData, Blob, BufferSource, or URLSearchParams
  referrer: "about:client", // or "" to send no Referer header,
  // or an url from the current origin
  referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache, or only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // a hash, like "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // AbortController to abort request
  window: window // null
});